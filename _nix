#compdef nix
#autoload

# Most information is extractable from `nix --help` and `nix command --help`

# There's four different types of options and arguments which is passed to _arguments:
#
# 1. The main commands which we get from nix --help or a subcommand accepting commands
#    such as nix flake --help
#
# 2. The common options which are hardcoded for the moment
#
# 3. The regular arguments for the active command. The number and types of these
# arguments are taken from the "Usage:" line of `nix command --help`, $state
# is set to the name of the argument via a `->$arg` action, which are further
# handled in the case statement at the end of the file.
#
# 4. The options for the active command. These are taken from the "Flags:"
# section of `nix command --help`, and the option arguments are handled in the
# same way as in 3.

# Ensure access to eg. _nix_complete_attr_paths
_nix-common-options

setopt extendedglob

type nix &> /dev/null || return

function _nix_cmd_dispatch_comp {
    local context state state_descr line
    typeset -A opt_args

    # This is a ternary value which indicates whether a subcommand of a subcommand
    # (e.g. nix flake <COMMAND>) is about to get completed. It will be assigned to one of
    # the following three states:
    # * -1: No subcommand-completion needs to happen.
    # *  0: No subcommand completion will happen since a subcommand of a subcommand that
    #       doesn't have further subcommands needs to be completed.
    # *  1: We are in a subcommand and want to complete the available commands such as
    #       nix flake update.
    local has_subcmd=-1

    # Extract the main commands of `nix` or a "recursive" subcommand such as `nix flake`.
    # For this purpose, the current command (`$words`) gets shortened until there's only a
    # command left that accepts subcommands.
    #
    # This is needed to either complete subcommands or to extract the information for
    # the currently active command to complete (see above comment for the general workflow
    # of this completion).
    local -a top_help
    local words_p="${words[@]}"
    while [ -z "${top_help}" ]; do
        local -a result=(${(f)"$(${=words_p:-nix} --help 2>/dev/null)"})

        # Check if the current helptext is displayed for a command accepting subcommands.
        if grep -q $'\e'"\[1m.*commands:"$'\e'"\[0m" <<< "$result"; then
            if [ "${#${=$(sed -re 's/-[^ ]+//g' <<< "$words_p")}}" -gt 1 ] && [ $has_subcmd -eq -1 ]; then
                has_subcmd=1
            fi
            top_help=($result)
            break
        fi

        # If a shortened version of `$words` is the main-command, no subcommand will
        # be completed. Otherwise e.g. `nix flake update` would still complete subcommands
        # for `nix flake`.
        if [ -n "${result}" ]; then
            has_subcmd=0
        fi
        words_p="$(sed -re "s/(.*)[ ]+\$/\1/" -re "s/(.*) [^ ]+\$/\1/" <<< "$words_p")"
    done

    local -a common_options
    # See per command flag handling for comments
    local common_options_descriptions=(${top_help:#^(  -*|  ??? -*)})
    local option_description= option=
    for option_description in $common_options_descriptions; do
        local description=${option_description/(*  )/}
        local option_spec=${option_description%$description}
        local -a option_group=(${=option_spec//($'\e\[3m'*|,)/})
        local -a option_args=(${=option_spec//(*$option_group[${#option_group}]|$'\e\[3m'|$'\e\[0m')/})

        local ACTIONS=""
        for arg in $option_args; do
            # Prefix with ':*' if $arg ends in 'S', ie. is plural
            local plural="${${(M)arg:#*S}:+:*}"
            ACTIONS+="$plural:$arg:->$arg"
        done

        for option in $option_group; do
            if [[ "$option" == "--option" ]]; then
                common_options+=("*${option}[$description]:option:->nixoption:value:->nixoptionvalue")
            elif  [[ "$option" == "--log-format" ]]; then
                common_options+=('--log-format[format of log output]:format:_nix_log_formats')
            else
                # Default to mutually exclusive non-repeatable options
                common_options+=("($option_group)"$option"[$description]"$ACTIONS)
            fi
        done
    done

    # The --store option is undocumented for some reason
    common_options+=("--store[Select a nix store]:Store:->STORE-URI")
    common_options+=('--experimental-features[Which Features to enable]:features:_nix_exp_feat')

    local -a main_commands
    # Extract the commands with descriptions
    # like ('command:some description' 'run:run some stuff'):
    #
    # Split the help output on newlines, and remove all lines which doesn't start
    # with two spaces and a lower case character,
    main_commands=(${top_help:#^(  [a-z]*)})
    # Strip the leading spaces
    main_commands=(${main_commands/#  /})
    # And replace the whitespace separating the command and description with ':'
    main_commands=(${main_commands/  ##/:})

    # Add commands to an associative array for easy lookup
    local -A command_lookup
    local command_description
    for command_description in $main_commands; {
        local command=${command_description%%\:*}
        command_lookup[$command]=1
    }

    local -a command_options=()
    local -a command_arguments=()
    # Setup the correct command_arguments and command_options depending on which
    # command we've typed
    _arguments '*: :->subcmd' && return 0

    # Extract the command we're about to complete. The command must be the first string
    # after the current (sub)command (which can be e.g. `nix` or `nix flake`) that is not
    # an option.
    local cmd
    for i in "${=${words[@]}/$words_p/}"; do
        if [[ "$i" == -* ]] || [[ -z "$i" ]]; then
            continue
        fi
        cmd="$i"
        break
    done

    # Check if we're in a valid command
    if [[ $command_lookup[$cmd] == 1 ]]; then
        local -a help=(${(f)"$(${=words_p} $cmd --help 2>/dev/null)"})
        # Extract an array describing the possible arguments to the command eg.
        # (NAR PATH) for cat-nar or (INSTALLABLES) for run
        local -a args=(${=${help[1]//$'\e\[1m'Usage:$'\e\[0m'}//(*FLAGS|.|$'\e\[3m'|$'\e\[0m')/})
        # And add the appropriate _argument spec
        local arg
        for arg in $args; do
            local _arg=${arg%?}
            # Prefix * if $arg ends in 'S', ie. is plural
            local plural="${${(M)_arg:#*S}:+*}"
            command_arguments+=("$plural:$_arg:->$_arg")
        done

        # Extract the lines containing the option descriptions
        local -a option_descriptions
        option_descriptions=(${help:#^(  -*|  ??? -*)})

        local option_description= option=
        for option_description in $option_descriptions; do

            # Extract the description by stripping everything up to the the last
            # two consecutive spaces
            local description=${option_description/(*  )/}
            # Remove the description from the help line
            local option_spec=${option_description%$description}

            # Extract the options by stripping everything starting at '\e[3m' (and ',')
            local -a option_group=(${=option_spec//($'\e\[3m'*|,)/})
            # Extract any arguments, by stripping the options (and \e[3m|\e[0m)
            local -a option_args=(${=option_spec//(*$option_group[${#option_group}]|$'\e\[3m'|$'\e\[0m')/})

            local ACTIONS=""
            for arg in $option_args; do
                # Prefix with ':*' if $arg ends in 'S', ie. is plural
                local plural="${${(M)arg:#*S}:+:*}"
                ACTIONS+="$plural:$arg:->$arg"
            done

            for option in $option_group; do
                # Handle `run --keep/--unset` manually as there's ambiguity the NAME argument
                if [[ $cmd == run && -z ${option:#(-k|--keep|-u|--unset)} ]]; then
                    command_options+=("*${option}[$description]:Environment Variable:_parameters")
                elif [[ $cmd = run && $option == (-c|--command) ]]; then
                    command_options+=("${option}[$description]:command: _nix_run_command_names:*::args: _normal")
                elif [[ "$cmd" == add-to-store \
                            && "$option" == (-n|--name) ]]; then
                    # Another <NAME> ambiguity
                    command_options+=("($option_group)"$option"[$description]:->store-name")
                elif [[ $option == (-I|--include) ]]; then
                    # Special handling of --include due to type ambiguity
                    command_options+=("*${option}[$description]:Includes:->INCLUDE")
                elif [[ -z ${option:#(--arg|--argstr|-f|--file)} ]]; then
                    # Repeatable options
                    command_options+=("*${option}[$description]"$ACTIONS)
                    if [[ $option == -f ]]; then
                        # -f. is accepted shorthand for -f .
                        command_options+="-f.[${description/FILE/\./default.nix}]"
                    fi
                else
                    # Default to mutually exclusive non-repeatable options
                    command_options+=("($option_group)"$option"[$description]"$ACTIONS)
                fi
            done
        done
    fi

    if [ $has_subcmd -eq 1 ]; then
        _describe -t main_commands Command main_commands && return 0
    fi
    _arguments -s \
               ":Command: _describe -t main_commands Command main_commands"\
               $command_arguments \
               $common_options \
               $command_options && return 0

    # Handle arguments to commands and options
    case "${context%%-*} $state" in
        'argument FLAKE-URL')
            _message "Not implemented yet"
            return
            ;;
        'argument '(INSTALLABLES|INSTALLABLE|PACKAGE|DEPENDENCY))
            # Complete attribute paths and files starting with either "/" or "./"

            # We need to prefix relative paths with ./ so nix will evaluate it as a
            # path
            local prefix='-P ./'
            local current_word=$words[$CURRENT]
            # When referencing an absolute path we can't prefix with ./
            if [[ -z ${current_word:##(/*|\~/*)} && -n $current_word ]]; then
                prefix=""
            fi
            _alternative \
                'path:Attribute path: _nix_complete_attr_paths' \
                "file:File path to package:_files ${prefix}"
            return
            ;;
        'argument '(PATH|PATHS))
            _files
            return
            ;;
        'argument ARG')
            _nix_cmd_dispatch_comp
            return
            ;;
        'argument FILES')
            _nix_complete_dotnix_files
            return
            ;;
        'argument NAR')
            _files -X "NAR"
            return
            ;;
        'argument REGEX')
            _message 'Regex to search for'
            return
            ;;
        'argument STRINGS')
            _message 'HASH to convert to a different base'
            return
            ;;
        'option PROFILE-DIR')
            _nix_profiles
            return
            ;;
        'option NAME')
            _nix_complete_function_arg
            return
            ;;
        'option EXPR')
            _message 'Expression argument'
            return
            ;;
        'option STRING')
            _message 'String argument'
            return
            ;;
        'option STORE-URI')
            local -a others=(
                'local:Use /nix/store'
                'remote:Go via the Nix daemon'
                'https\://:HTTPS'
                's3\://:S3 binary cache'
                'ssh\://:Nix store over ssh')
            _alternative \
                'file:Use a chroot store:_directories' \
                'url:Other: _describe "URLS and special options" others' \
                'cache:Local binary cache (adds file url prefix):_path_files -P "file://" -/'
            return
            ;;
        'option FILE')
            _nix_complete_dotnix_files
            return
            ;;
        'option FILES'|'option PATH')
            _files
            return
            ;;
        'option COMMAND')
            _command_names -e
            return
            ;;
        'option ARGS')
            _message 'Arguments to command'
            return
            ;;
        'option TYPE')
            _values 'Hash type' md5 sha1 sha256 sha512
            return
            ;;
        'option INCLUDE')
            # --include <PATH> completion
            _nix_complete_includes
            return
            ;;
        'option nixoption')
            _nix_options
            return
            ;;
        'option nixoptionvalue')
            _nix_options_value
            return
            ;;
        *)
            # Fallback to argument name description
            _message "$state_descr"
    esac
}

_nix_cmd_dispatch_comp
